# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XNCVf70uWqSfEDHkg-ckqmPXpYgXM_hu
"""

# app.py

import streamlit as st
import openpyxl
from openpyxl.styles import PatternFill
from openpyxl import load_workbook
from datetime import datetime
import re
import io

# ------------------------------------------------------------------
# Global Variables / Session State Setup
# ------------------------------------------------------------------
# Use session_state to store the uploaded file path and processed workbook.
if "uploaded_filepath" not in st.session_state:
    st.session_state.uploaded_filepath = None
if "processed_wbs" not in st.session_state:
    st.session_state.processed_wbs = {}
if "full_bank_txns" not in st.session_state:
    st.session_state.full_bank_txns = None
if "full_book_txns" not in st.session_state:
    st.session_state.full_book_txns = None

# ------------------------------------------------------------------
# Define color fills for conditional formatting.
# ------------------------------------------------------------------
green_fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")  # matched
red_fill   = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")    # unmatched

# ------------------------------------------------------------------
# Utility: Extract numeric tokens with tail.
# For each token with >=4 digits, also add its last 4 digits.
# ------------------------------------------------------------------
def extract_numbers_with_tail(text):
    if text is None:
        return set()
    tokens = re.findall(r'\d+', str(text))
    result = set(tokens)
    for token in tokens:
        if len(token) >= 4:
            result.add(token[-4:])
    return result

# ------------------------------------------------------------------
# Part 1: File Upload
# ------------------------------------------------------------------
st.title("Data Processing App")
st.header("1) Upload File")
uploaded_file = st.file_uploader("Upload an XLSX file", type="xlsx")
if uploaded_file is not None:
    # Save the uploaded file temporarily as "uploaded_file.xlsx"
    with open("uploaded_file.xlsx", "wb") as f:
        f.write(uploaded_file.getbuffer())
    st.success("File uploaded successfully!")
    st.session_state.uploaded_filepath = "uploaded_file.xlsx"

# ------------------------------------------------------------------
# Part 2: Common Processing Functions
# ------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Extraction Routine: Returns lists of bank and book transactions.
# -----------------------------------------------------------------------------
def extract_transactions(ws):
    bank_txns = []
    book_txns = []
    # Data rows start at row 2.
    for row in ws.iter_rows(min_row=2):
        # Bank fields (Columns A–E):
        bank_date = row[0].value         # Column A: Bank Date
        bank_narration = row[2].value      # Column C: Transaction Particulars (narration)
        bank_amount = row[3].value         # Column D: Bank Amount
        bank_dr_cr = row[4].value          # Column E: Bank DR/CR
        # Book fields (Columns F–P):
        book_amount = row[5].value         # Column F: Book Amount
        book_date = row[8].value           # Column I: Book Date
        book_description = row[13].value   # Column N: Book Description (narration)
        book_dr_cr = row[15].value         # Column P: Book DR/CR

        if bank_amount is not None:
            bank_txns.append({
                'row': row,
                'date': bank_date,
                'amount': bank_amount,
                'dr_cr': bank_dr_cr,
                'narration': bank_narration,
                'cell': row[3],          # For coloring the bank Amount cell.
                'matched': False,
                'narration_matched': False
            })
        if book_amount is not None:
            book_txns.append({
                'row': row,
                'date': book_date,
                'amount': book_amount,
                'dr_cr': book_dr_cr,
                'description': book_description,
                'cell': row[5],          # For coloring the book Amount cell.
                'matched': False,
                'reversal': False,
                'narration_matched': False
            })
    return bank_txns, book_txns

# -----------------------------------------------------------------------------
# Routine: Create Extra Sheets (Reversals, Missing in Book, Extra in Book)
# -----------------------------------------------------------------------------
def create_extra_sheets(wb, bank_txns, book_txns):
    ws = wb.active
    # Reversal detection among Book transactions.
    reversal_rows = []
    for i in range(len(book_txns)):
        if not book_txns[i]['reversal']:
            for j in range(i+1, len(book_txns)):
                if not book_txns[j]['reversal']:
                    if book_txns[i]['amount'] == book_txns[j]['amount']:
                        if ((book_txns[i]['dr_cr'] == "DR" and book_txns[j]['dr_cr'] == "CR") or
                            (book_txns[i]['dr_cr'] == "CR" and book_txns[j]['dr_cr'] == "DR")):
                            if book_txns[i]['date'] is not None and book_txns[j]['date'] is not None:
                                diff_days = abs((book_txns[i]['date'] - book_txns[j]['date']).days)
                                if diff_days <= 10:
                                    book_txns[i]['reversal'] = True
                                    book_txns[j]['reversal'] = True
                                    reversal_rows.append(book_txns[i]['row'])
                                    reversal_rows.append(book_txns[j]['row'])
                                    break
    rev_sheet = wb.create_sheet("Reversals")
    for r in reversal_rows:
        rev_sheet.append([cell.value for cell in r[5:16]])

    miss_sheet = wb.create_sheet("Missing in Book")
    for txn in bank_txns:
        if not txn['matched']:
            miss_sheet.append([cell.value for cell in txn['row']])

    extra_sheet = wb.create_sheet("Extra in Book")
    for txn in book_txns:
        if not txn['matched']:
            extra_sheet.append([cell.value for cell in txn['row']])

# -----------------------------------------------------------------------------
# Stage 2: Matched Amounts (Amount Only)
# -----------------------------------------------------------------------------
def process_amount_only():
    if not st.session_state.uploaded_filepath:
        st.error("Please upload a file first.")
        return None
    wb = load_workbook(st.session_state.uploaded_filepath)
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount']:
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break
    # Set cell fill colors.
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

# -----------------------------------------------------------------------------
# Stage 3: DRCR/CRDR (Amount + DR/CR)
# -----------------------------------------------------------------------------
def process_drcr():
    if not st.session_state.uploaded_filepath:
        st.error("Please upload a file first.")
        return None
    wb = load_workbook(st.session_state.uploaded_filepath)
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if (btxn['amount'] == bktxn['amount'] and
                    ((btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                     (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR"))):
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

# -----------------------------------------------------------------------------
# Stage 4: Date (Amount + DR/CR + Date)
# -----------------------------------------------------------------------------
def process_date():
    if not st.session_state.uploaded_filepath:
        st.error("Please upload a file first.")
        return None
    wb = load_workbook(st.session_state.uploaded_filepath)
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if (btxn['amount'] == bktxn['amount'] and
                    ((btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                     (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR"))):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            break
                    else:
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

# -----------------------------------------------------------------------------
# Stage 5: Check Narration (All Conditions)
# Standard matching (Amount + DR/CR + Date) plus narration matching (numeric tokens)
# -----------------------------------------------------------------------------
def process_full():
    if not st.session_state.uploaded_filepath:
        st.error("Please upload a file first.")
        return None
    wb = load_workbook(st.session_state.uploaded_filepath)
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    standard_pairs = []
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if (btxn['amount'] == bktxn['amount'] and
                    ((btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                     (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR"))):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            standard_pairs.append((btxn, bktxn))
                            break
                    else:
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        standard_pairs.append((btxn, bktxn))
                        break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill

    # Narration matching: check numeric tokens.
    final_pairs = []
    for pair in standard_pairs:
        btxn, bktxn = pair
        bank_tokens = extract_numbers_with_tail(btxn.get('narration'))
        book_tokens = extract_numbers_with_tail(bktxn.get('description'))
        if bank_tokens and book_tokens:
            inter = bank_tokens.intersection(book_tokens)
            if inter:
                btxn['narration_matched'] = True
                bktxn['narration_matched'] = True
                final_pairs.append((btxn, bktxn, inter))
    create_extra_sheets(wb, bank_txns, book_txns)

    # Create "Matched Entries" sheet.
    me_sheet = wb.create_sheet("Matched Entries")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    extra_cols = ["Matched Bank Tokens", "Matched Book Tokens"]
    me_sheet.append(bank_header + book_header + extra_cols)
    for pair in final_pairs:
        btxn, bktxn, tokens = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        token_str = ", ".join(sorted(tokens))
        me_sheet.append(bank_data + book_data + [token_str, token_str])

    # Save processed lists for additional matching.
    st.session_state.full_bank_txns = bank_txns
    st.session_state.full_book_txns = book_txns
    return wb

# -----------------------------------------------------------------------------
# Stage 6: Additional Matching (Final)
# Uses only bank transactions not narration_matched and matches them with remaining book transactions.
# -----------------------------------------------------------------------------
def process_additional():
    if st.session_state.full_bank_txns is None or st.session_state.full_book_txns is None:
        st.error("Please run the 'Check Narration (All Conditions)' stage first.")
        return None
    remaining_bank = [b for b in st.session_state.full_bank_txns if not b.get('narration_matched')]
    remaining_book = [b for b in st.session_state.full_book_txns if not b.get('narration_matched')]
    additional_matches = []
    used_book_indices = set()
    for btxn in remaining_bank:
        for idx, bktxn in enumerate(remaining_book):
            if idx in used_book_indices:
                continue
            if btxn['amount'] == bktxn['amount'] and (
                (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
            ):
                additional_matches.append((btxn, bktxn))
                used_book_indices.add(idx)
                btxn['matched'] = True
                bktxn['matched'] = True
                break
    # Create "Additional Matching" sheet.
    wb = load_workbook(st.session_state.uploaded_filepath)  # reload base workbook
    ws = wb.active
    add_sheet = wb.create_sheet("Additional Matching")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    add_sheet.append(bank_header + book_header + ["Additional Match Status"])

    for pair in additional_matches:
        btxn, bktxn = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        add_sheet.append(bank_data + book_data + ["Matched"])

    for btxn in remaining_bank:
        if not btxn.get('matched'):
            bank_data = [cell.value for cell in btxn['row'][0:5]]
            blank_book = ["" for _ in range(11)]
            add_sheet.append(bank_data + blank_book + ["Unmatched Bank"])
            btxn['cell'].fill = red_fill
    for bktxn in remaining_book:
        if not bktxn.get('matched'):
            blank_bank = ["" for _ in range(5)]
            book_data = [cell.value for cell in bktxn['row'][5:16]]
            add_sheet.append(blank_bank + book_data + ["Unmatched Book"])
            bktxn['cell'].fill = red_fill

    return wb

# ------------------------------------------------------------------
# Part 3: User Interface for Processing & Downloading
# ------------------------------------------------------------------
st.header("2) Processing Options")

# Define available processing stages.
processing_options = [
    "Matched Amounts (Amount Only)",
    "DRCR/CRDR (Amount + DR/CR)",
    "Date (Amount + DR/CR + Date)",
    "Check Narration (All Conditions)",
    "Additional Matching (Final)"
]
stage_option = st.selectbox("Select processing stage:", processing_options)

if st.button("Process File"):
    processed_wb = None
    if stage_option == "Matched Amounts (Amount Only)":
        processed_wb = process_amount_only()
    elif stage_option == "DRCR/CRDR (Amount + DR/CR)":
        processed_wb = process_drcr()
    elif stage_option == "Date (Amount + DR/CR + Date)":
        processed_wb = process_date()
    elif stage_option == "Check Narration (All Conditions)":
        processed_wb = process_full()
    elif stage_option == "Additional Matching (Final)":
        processed_wb = process_additional()

    if processed_wb is not None:
        st.session_state.processed_wbs[stage_option] = processed_wb
        # Save the processed workbook into a memory buffer for download.
        output = io.BytesIO()
        processed_wb.save(output)
        output.seek(0)
        st.success("File processed successfully!")
        st.download_button(
            label="Download Processed File",
            data=output,
            file_name=f"processed_{stage_option.replace(' ', '_').lower()}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )